<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastRTC Demo - éŸ³é¢‘å®æ—¶é€šä¿¡</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        button {
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-start {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-stop {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .status-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            color: #666;
            font-weight: 600;
        }

        .status-value {
            color: #333;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-indicator.connected {
            background: #4caf50;
            box-shadow: 0 0 10px #4caf50;
        }

        .status-indicator.disconnected {
            background: #f44336;
        }

        .log-panel {
            background: #1e1e1e;
            color: #00ff00;
            border-radius: 10px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid #00ff00;
            padding-left: 10px;
        }

        .log-entry.error {
            border-left-color: #ff0000;
            color: #ff0000;
        }

        .log-entry.info {
            border-left-color: #00bfff;
            color: #00bfff;
        }

        .visualizer {
            width: 100%;
            height: 100px;
            background: #000;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .recording {
            animation: pulse 1.5s ease-in-out infinite;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ™ï¸ FastRTC Demo</h1>
        <p class="subtitle">åŸºäº WebRTC çš„å®æ—¶éŸ³é¢‘é€šä¿¡ç¤ºä¾‹</p>

        <canvas id="visualizer" class="visualizer"></canvas>

        <div class="control-panel">
            <div class="button-group">
                <button id="startBtn" class="btn-start">å¼€å§‹å½•éŸ³</button>
                <button id="replayBtn" class="btn-stop" disabled>åœæ­¢å¹¶å›æ”¾</button>
                <button id="disconnectBtn" style="background: #7f8c8d; color: white;" disabled>æ–­å¼€è¿æ¥</button>
            </div>
        </div>

        <div class="status-panel">
            <div class="status-item">
                <span class="status-label">è¿æ¥çŠ¶æ€</span>
                <span class="status-value">
                    <span id="statusIndicator" class="status-indicator disconnected"></span>
                    <span id="statusText">æœªè¿æ¥</span>
                </span>
            </div>
            <div class="status-item">
                <span class="status-label">éŸ³é¢‘çŠ¶æ€</span>
                <span class="status-value" id="audioStatus">æœªæ¿€æ´»</span>
            </div>
        </div>

        <div class="log-panel" id="logPanel">
            <div class="log-entry info">ç­‰å¾…ç”¨æˆ·æ“ä½œ...</div>
        </div>
    </div>

    <script>
        let peerConnection = null;
        let localStream = null;
        let remoteAudioElement = null;
        let audioContext = null;
        let analyser = null;
        let dataArray = null;

        const startBtn = document.getElementById('startBtn');
        const replayBtn = document.getElementById('replayBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const audioStatus = document.getElementById('audioStatus');
        const logPanel = document.getElementById('logPanel');
        const visualizer = document.getElementById('visualizer');
        const canvasCtx = visualizer.getContext('2d');

        // æ—¥å¿—å‡½æ•°
        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logPanel.appendChild(entry);
            logPanel.scrollTop = logPanel.scrollTop;
            console.log(message);
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus(connected, text) {
            statusIndicator.className = `status-indicator ${connected ? 'connected' : 'disconnected'}`;
            statusText.textContent = text;
        }

        // éŸ³é¢‘å¯è§†åŒ–
        function drawVisualization() {
            if (!analyser) return;

            requestAnimationFrame(drawVisualization);

            analyser.getByteTimeDomainData(dataArray);

            canvasCtx.fillStyle = 'rgb(0, 0, 0)';
            canvasCtx.fillRect(0, 0, visualizer.width, visualizer.height);

            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = 'rgb(0, 255, 0)';
            canvasCtx.beginPath();

            const sliceWidth = visualizer.width / dataArray.length;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                const v = dataArray[i] / 128.0;
                const y = (v * visualizer.height) / 2;

                if (i === 0) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            canvasCtx.lineTo(visualizer.width, visualizer.height / 2);
            canvasCtx.stroke();
        }

        // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
        async function initAudioContext(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.fftSize = 2048;
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            drawVisualization();
        }

        // å¼€å§‹ WebRTC è¿æ¥
        async function startConnection() {
            try {
                log('æ­£åœ¨è¯·æ±‚éº¦å…‹é£æƒé™...');

                // è·å–æœ¬åœ°éŸ³é¢‘æµ
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                log('éº¦å…‹é£æƒé™å·²è·å–', 'info');
                audioStatus.textContent = 'å·²æ¿€æ´»';

                // åˆå§‹åŒ–éŸ³é¢‘å¯è§†åŒ–
                await initAudioContext(localStream);

                // åˆ›å»º PeerConnection
                peerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                });

                // æ·»åŠ æœ¬åœ°éŸ³é¢‘è½¨é“
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                    log(`å·²æ·»åŠ éŸ³é¢‘è½¨é“: ${track.kind}`);
                });

                // ç›‘å¬è¿œç¨‹éŸ³é¢‘æµ
                peerConnection.ontrack = (event) => {
                    log('æ”¶åˆ°è¿œç¨‹éŸ³é¢‘æµ', 'info');
                    if (!remoteAudioElement) {
                        remoteAudioElement = new Audio();
                        remoteAudioElement.autoplay = true;
                    }
                    remoteAudioElement.srcObject = event.streams[0];
                };

                // ICE å€™é€‰å¤„ç†
                peerConnection.onicecandidate = async (event) => {
                    if (event.candidate) {
                        log('ç”Ÿæˆ ICE å€™é€‰');
                    }
                };

                // è¿æ¥çŠ¶æ€ç›‘å¬
                peerConnection.onconnectionstatechange = () => {
                    log(`è¿æ¥çŠ¶æ€: ${peerConnection.connectionState}`);
                    updateStatus(
                        peerConnection.connectionState === 'connected',
                        peerConnection.connectionState
                    );
                };

                // åˆ›å»º Offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                log('å·²åˆ›å»º SDP Offer');

                // å‘é€ Offer åˆ°æœåŠ¡å™¨
                // æ³¨æ„ï¼šè¿™é‡Œå‡è®¾ fastrtc æŒ‚è½½çš„ endpoint æ˜¯ /webrtc/offerï¼Œå¦‚æœä¸æ˜¯è¯·æ ¹æ®å®é™…æƒ…å†µä¿®æ”¹
                const response = await fetch('/webrtc/offer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sdp: offer.sdp,
                        type: offer.type
                    })
                });

                if (!response.ok) {
                    throw new Error(`æœåŠ¡å™¨å“åº”é”™è¯¯: ${response.status}`);
                }

                const answer = await response.json();
                log('æ”¶åˆ°æœåŠ¡å™¨ Answer', 'info');

                // è®¾ç½®è¿œç¨‹æè¿°
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                log('WebRTC è¿æ¥å·²å»ºç«‹!', 'info');

                updateStatus(true, 'æ­£åœ¨å½•éŸ³...');
                startBtn.disabled = true;
                replayBtn.disabled = false;
                disconnectBtn.disabled = false;

            } catch (error) {
                log(`é”™è¯¯: ${error.message}`, 'error');
                updateStatus(false, 'è¿æ¥å¤±è´¥');
                disconnect();
            }
        }

        // è§¦å‘å›æ”¾
        async function startReplay() {
            try {
                replayBtn.disabled = true;
                log('æ­£åœ¨è¯·æ±‚å›æ”¾...', 'info');
                updateStatus(true, 'æ­£åœ¨å›æ”¾...');

                const response = await fetch('/replay', { method: 'POST' });
                const data = await response.json();

                if (data.status === 'ok') {
                    log(`å›æ”¾å¼€å§‹ï¼Œæ–‡ä»¶: ${data.file}`, 'info');
                } else {
                    log(`å›æ”¾å¤±è´¥: ${data.message}`, 'error');
                    replayBtn.disabled = false;
                }
            } catch (e) {
                log(`è¯·æ±‚å›æ”¾å‡ºé”™: ${e}`, 'error');
                replayBtn.disabled = false;
            }
        }

        // æ–­å¼€è¿æ¥
        function disconnect() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            if (remoteAudioElement) {
                remoteAudioElement.srcObject = null;
                remoteAudioElement = null;
            }

            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            updateStatus(false, 'æœªè¿æ¥');
            audioStatus.textContent = 'æœªæ¿€æ´»';
            startBtn.disabled = false;
            replayBtn.disabled = true;
            disconnectBtn.disabled = true;
            log('è¿æ¥å·²å…³é—­');
        }

        // äº‹ä»¶ç›‘å¬
        startBtn.addEventListener('click', startConnection);
        replayBtn.addEventListener('click', startReplay);
        disconnectBtn.addEventListener('click', disconnect);

        // è®¾ç½® canvas å°ºå¯¸
        visualizer.width = visualizer.offsetWidth;
        visualizer.height = visualizer.offsetHeight;
    </script>
</body>

</html>